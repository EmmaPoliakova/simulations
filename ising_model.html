<!-- Author: Emma Poliakova 2020 -->
<!-- Ising model cellular automata simulation using monte carlo principle and html canvas -->
<!DOCTYPE html>
<html>
    <head>
        <link rel="stylesheet" type="text/css" href="style.css">
        <style>
        </style>
    </head>

    <body onload='draw()'>
        <div>
            <canvas id='canvas' width='510' height='510'></canvas>
        </div>

        <div id=buttons>
            <button class="button" id="start" onclick="setUp()">Set Up</button>
            <button class="button" id="play" onclick="play()">Play</button>
            <button class="button" id="stop" onclick="stop()">Stop</button>
        </div>
        <div class="slidecontainer">
            <p>Temperature: <span id="temperature"></span></p>
            <input type="range" min="0" max="500" value="0" class="slider" id="myRange">
        </div>

    <script>
        var canvas = document.getElementById('canvas');
        var context = canvas.getContext('2d');
        var size = 102;
        var length = 101;
        var square_size = 5;
        var cells = createArray(size, size);
        var game;
        var T = 0;
        var x = 0;

        var slider = document.getElementById("myRange");
        var output = document.getElementById("temperature");
        output.innerHTML = slider.value;
        slider.oninput = function() {
            output.innerHTML = this.value/100;
            T = this.value/100;
    }

       // canvas frame and initial set up
       function draw() {
            if (canvas.getContext) {
                var context = canvas.getContext('2d');
                context.strokeStyle='black';


                context.moveTo(square_size, canvas.width-square_size);
                context.lineTo(canvas.width-square_size, canvas.width-square_size);


                context.moveTo(canvas.width-square_size, square_size);
                context.lineTo(canvas.width-square_size, canvas.width-square_size);


                context.moveTo(square_size, square_size);
                context.lineTo(canvas.width-square_size, square_size);


                context.moveTo(square_size, square_size);
                context.lineTo(square_size,canvas.width-square_size);
                context.stroke();

                setUp();
                }


            }

        // create n x n array
        function createArray(length) {
            var arr = new Array(length || 0),
            i = length;

            if (arguments.length > 1) {
                var args = Array.prototype.slice.call(arguments, 1);
                while(i--) arr[length-1 - i] = createArray.apply(this, args);
            }

            return arr;
        }

        // generate and draw cells with +1 or -1 spin
        function setUp(){
            var spin;
            for (var i=0 ;i<size; i+=1) {
                cells[i][0] = 0;
                cells[i][length] = 0;
            }

            for (var j=0 ; j<size; j+=1) {
                cells[0][j] = 0;
                cells[length][j] = 0;
            }

            for (var i=1 ; i<length; i+=1) {
                for (var j=1 ;j<length; j+=1) {
                    spin = Math.floor(Math.random() * 2);
                    if (spin == 0){
                         cells[i][j] = -1;
                         context.beginPath();
                         context.fillStyle = "#40ade8";
                         context.fillRect(i*square_size, j*square_size, square_size, square_size); }

                    else {
                         cells[i][j] = 1;
                         context.beginPath();
                         context.fillStyle = "white";
                         context.fillRect(i*square_size, j*square_size, square_size, square_size);
                         }
                }
            }
        }

        // monte carlo game step for random cells --> calculate energy and draw
        function gameStep(){
            var cell_list =[];
            for (var z=0 ; z<200; z+=1){
                var i = Math.floor(Math.random() * 100)+1;
                var j = Math.floor(Math.random() * 100)+1;
                var spin = cells[i][j];

                var E = -1*cells[i][j]*(cells[i-1][j] + cells[i+1][j] + cells[i][j-1] + cells[i][j+1]);
                if (E>0){
                    cells[i][j] = -1 * cells[i][j]; }
                else {
                    var r = Math.floor(Math.random() * 1000)/1000;
                    if (r < Math.pow(Math.E, (2*E/T))){
                        cells[i][j] = -1 * cells[i][j];}
                }
                if (spin != cells[i][j]){
                    cell_list.push([i,j]);}
            }

            for (x of cell_list){
                if (cells[i][j] > 0){
                    context.beginPath();
                    context.fillStyle = "white";
                    context.fillRect(i*square_size, j*square_size, square_size, square_size);
                }
                else{
                    context.beginPath();
                    context.fillStyle = "#40ade8";
                    context.fillRect(i*square_size, j*square_size, square_size, square_size);
                }

            }

        }

        function play(){
            game = setInterval(gameStep, 0.001);
            }

        function stop(){
            clearInterval(game);
        }

    </script>
    </body>
</html>